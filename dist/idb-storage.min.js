var idbStorage=function(e){"use strict";const t="undefined"!=typeof navigator&&/iP(hone|(o|a)d);/.test(navigator.userAgent);function n(){let e=Promise.resolve();return{use:function(t){const n=e.then(t);return e=n.catch(()=>{}),n},acquire:function(){let t;const n=e.then(()=>t);return e=new Promise(e=>{t=e}),n}}}function r(e){return new Promise((t,n)=>{e.onsuccess=(()=>t(e.result)),e.onerror=n})}function a({name:e,version:t,onupgradeneeded:n,indexedDB:r=o()}){if(!e)throw new Error("missing storage name");if(!r)throw new Error("missing indexedDB");let a,s=0;return{use:c,startTransaction:function(e,t,n){return c(async r=>{const a=r.transaction(e,t),[o]=await Promise.all([n(a),new Promise((e,t)=>{a.oncomplete=(()=>e()),a.onerror=t})]);return o})}};async function c(o){s++,a||(a=new Promise((a,o)=>{const s=r.open(e,t);s.onerror=o,s.onsuccess=(()=>a(s.result)),s.onupgradeneeded=n}));const c=await a;let i,u;try{u=await o(c)}catch(e){i=e}if(--s||(c.close(),a=null),i)throw i;return u}}function o(){return"undefined"!=typeof indexedDB?indexedDB:"undefined"!=typeof webkitIndexedDB?webkitIndexedDB:"undefined"!=typeof mozIndexedDB?mozIndexedDB:"undefined"!=typeof OIndexedDB?OIndexedDB:"undefined"!=typeof msIndexedDB?msIndexedDB:null}return e.createIDBStorage=function({name:e,conflictAction:o="throw",indexedDB:s}={}){const c=a({indexedDB:s,name:e,version:1,onupgradeneeded:function(e){e.oldVersion<1&&(e.target.result.createObjectStore("metadata"),e.target.result.createObjectStore("resource"))}}),i=new Map;let u;return function(e){for(const[t,n]of Object.entries(e))e[t]=(async(...e)=>(u||(u=c.startTransaction(["metadata"],"readonly",async e=>{const t=e.objectStore("metadata"),[n,a]=await Promise.all([r(t.getAllKeys()),r(t.getAll())]);for(let e=0;e<n.length;e++)i.set(n[e],d(a[e]))})),await u,await n(...e)));return e}({set:function(e,n,r={}){return l(e,async a=>{if(a.meta){if("throw"===o)throw new Error(`idb-storage key conflict: ${e}`);if("ignore"===o)return a.meta;if("stack"===o)return await f(e,a)}r.stack=0,t&&n instanceof Blob?(r.blobType=n.type,n=await function(e){return new Promise((t,n)=>{const r=new FileReader;r.onload=(()=>t(r.result)),r.onerror=n,r.readAsArrayBuffer(e)})}(n)):r.blobType=null,r.size=n.size||n.byteLength||n.length;const s=Object.assign({},a.meta,r);return await c.startTransaction(["metadata","resource"],"readwrite",t=>{const r=t.objectStore("metadata"),a=t.objectStore("resource");r.put(s,e),a.put(n,e)}),a.meta=s,s})},delete:function(e){return l(e,async t=>{t.meta&&(t.meta.stack?t.meta.stack--:(await c.startTransaction(["metadata","resource"],"readwrite",t=>{const n=t.objectStore("metadata"),r=t.objectStore("resource");n.delete(e),r.delete(e)}),t.meta=null))})},deleteMany:function(e){return async function(e,t){const n=e.map(e=>{let t=i.get(e);return t||(t=d(),i.set(e,t)),t}),r=await Promise.all(n.map(e=>e.lock.acquire()));let a,o;try{o=await t(n)}catch(e){a=e}for(const e of r)e();if(a)throw a;return o}(e,async t=>{await c.startTransaction(["metadata","resource"],"readwrite",n=>{const r=n.objectStore("metadata"),a=n.objectStore("resource");for(let n=0;n<e.length;n++)t[n].meta&&!t[n].meta.stack&&(r.delete(e[n]),a.delete(e[n]))});for(const e of t)e.meta&&(e.meta.stack?e.meta.stack--:e.meta=null)})},get:function(e){return l(e,async t=>{if(!t.meta)throw new Error(`missing key: ${e}`);const n=await c.startTransaction(["resource"],"readonly",t=>{const n=t.objectStore("resource");return r(n.get(e))});return null!=t.meta.blobType?new Blob([n],t.meta.blobType):n})},getMeta:function(e){return l(e,t=>{if(!t.meta)throw new Error(`missing key: ${e}`);return t.meta})},stackUp:function(e){return l(e,t=>f(e,t))}});function d(e){return{lock:n(),meta:e}}function l(e,t){let n=i.get(e);return n||(n=d(),i.set(e,n)),n.lock.use(()=>t(n))}async function f(e,t){if(!t.meta)throw new Error(`missing key: ${e}`);const n=Object.assign({},t.meta);return n.stack++,await c.startTransaction(["metadata"],"readwrite",t=>{t.objectStore("metadata").put(n,e)}),t.meta=n,n}},e.createLock=n,e}({});
